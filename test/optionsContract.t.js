/**
 *
 * autogenerated by solidity-visual-auditor
 *
 * execute with:
 *  #> truffle test <path/to/this/test.js>
 *
 * */

const promisify = (inner) =>
  new Promise((resolve, reject) =>
    inner((err, res) => {
      if (err) { reject(err) }

      resolve(res);
    })
  );

const Util = require('./util.js');
const Web3 = require('web3');
const web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'))
const util = new Util(web3);
var expect = require('expect');
var OptionsContract = artifacts.require("/Users/zubinkoticha/WebstormProjects/OptionsProtocol/contracts/OptionsContract.sol");
var OptionsFactory = artifacts.require("/Users/zubinkoticha/WebstormProjects/OptionsProtocol/contracts/OptionsFactory.sol");
var OptionsContractJSON = require("../build/contracts/OptionsContract.json");
var OptionsContractABI = OptionsContractJSON.abi;
var { ContractCreated }= require('./utils/FactoryEvents.js')

const truffleAssert = require('truffle-assertions');
// var AssetAdded = FactoryEvents.AssetAdded;

contract('OptionsContract', (accounts) => {
  var creatorAddress = accounts[0];
  var firstOwnerAddress = accounts[1];
  var secondOwnerAddress = accounts[2];
  var externalAddress = accounts[3];
  var unprivilegedAddress = accounts[4]
  /* create named accounts for contract roles */

  let optionsContract;


    let ConstructorArgs = {
      collateralAddr:  "0x0000000000000000000000000000000000000000",
      underlyingAddr :  "0x0000000000000000000000000000000000000000",
      strikePrice: 95,
      strikeAddr: "0x0000000000000000000000000000000000000000",
      payoutAddr: "0x0000000000000000000000000000000000000000",
      expiry: 1239823
    }

  before(async () => {
    // optionsContract = await OptionsContract.deployed(
    //   ConstructorArgs.collateralAddr,
    //   ConstructorArgs.underlyingAddr,
    //   ConstructorArgs.strikePrice,
    //   ConstructorArgs.strikeAddr,
    //   ConstructorArgs.payoutAddr,
    //   ConstructorArgs.expiry);
    try {
      var optionsFactory = await OptionsFactory.deployed();
      // const result = await optionsFactory.addAsset(
      //   "ETH",
      //   "0x0000000000000000000000000000000000000001"
      // );
      //TODO: why does uncommenting the above cause errors?


      var optionsContractResult = await optionsFactory.createOptionsContract(
        "ETH",
        "ETH",
        "96",
        "ETH",
        "ETH",
        "1577836800",
      );

      const optionsContractAddr = optionsContractResult.logs[0].args[0];

      // // var optionsContractAddr = optionsContractLog.logs[0].args[0];
      // console.log(optionsContractAddr)

      //
      optionsContract = new web3.eth.Contract(OptionsContractABI,optionsContractAddr, {from: creatorAddress, gasPrice: '20000000000'})


      // console.log(repoIndex)
      // // const repoIndex = res.returnValues();
      // console.log(repoIndex)
      // console.log(repoIndex[0])

      // console.log(result)
      // truffleAssert.eventEmitted(result, 'RepoOpened', (ev) => {
      //         return ev.repoIndex === '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359'
      //       });

      // // console.log(web3.eth.estimateGas({from: creatorAddress, to: "0xEDA8A2E1dfA5B93692D2a9dDF833B6D7DF6D5f93", amount: web3.toWei(1, "ether")}))
      // // console.log(web3.eth.estimateGas({from: creatorAddress, to: "0xEDA8A2E1dfA5B93692D2a9dDF833B6D7DF6D5f93", amount: web3.toWei(1, "ether")}))
      //
      // console.log(await promisify(cb =>  optionsContract.methods.openRepo().estimateGas(cb)))
      //
      // console.log(await promisify(cb =>  optionsContract.methods.openRepo().send({from: creatorAddress, gas: '31272'}, cb)))

      // console.log(optionsContract.methods)
      // console.log(optionsContract.methods.openRepo.call());
      // console.log(optionsContract.methods.collateralizationRatio())
      // console.log(optionsContract.methods.collateralizationRatio())
      // console.log(optionsContract.methods.collateralizationRatio())
      // console.log(optionsContract.methods.collateralizationRatio())
      // console.log(optionsContract.methods.collateralizationRatio())
      // console.log(optionsContract.methods.collateralizationRatio())

      // const repoIndex = await optionsContract


    } catch (err) {
      console.error(err);
      expect.fail("didn't create optionsContract correctly");
    }

  });

  describe("#openRepo()", () => {
    it("should open first repo correctly", async () => {
      var result = await promisify(cb =>  optionsContract.methods.openRepo().send({from: creatorAddress, gas: '100000'}, cb))
      var returnValues = (await optionsContract.getPastEvents( 'RepoOpened', { fromBlock: 0, toBlock: 'latest' } ))[0].returnValues;
      var repoIndex = returnValues.repoIndex;
      expect(repoIndex).toBe("0");
    })

    it("should open second repo correctly", async () => {
      var result = await promisify(cb =>  optionsContract.methods.openRepo().send({from: creatorAddress, gas: '100000'}, cb))
      var returnValues1 = (await optionsContract.getPastEvents( 'RepoOpened', { fromBlock: 0, toBlock: 'latest' } ))[1].returnValues;
      var repoIndex1 = returnValues1.repoIndex;
      expect(repoIndex1).toBe("1");
    })


    it("should add ETH collateral successfully", async () => {
      var result = await promisify(cb =>  optionsContract.methods.openRepo().send({from: creatorAddress, gas: '100000'}, cb))
      var returnValues1 = (await optionsContract.getPastEvents( 'RepoOpened', { fromBlock: 0, toBlock: 'latest' } ))[1].returnValues;
      var repoIndex1 = returnValues1.repoIndex;
      expect(repoIndex1).toBe("1");
    })

    // it("fails if an asset is added twice", async () => {
    //   try {
    //     // await util.setBlockNumberForward(8);
    //     await optionsFactory.addAsset(
    //       "DAI",
    //       "0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359"
    //     )
    //
    //   } catch (err) {
    //     return;
    //     // console.log(err)
    //     // util.assertThrowMessage(err);
    //   }
    //   expect.fail("should throw error")
    // })


  });

  describe("#addETHCollateral()", () => {


    it("should add ETH collateral successfully", async () => {
      const repoNum = 1;
      var msgValue = "10000000";
      var result = await promisify(cb =>  optionsContract.methods.addETHCollateral(repoNum).send({from: creatorAddress, gas: '100000', value: msgValue}, cb))
      var returnValues = (await optionsContract.getPastEvents( 'ETHCollateralAdded', { fromBlock: 0, toBlock: 'latest' } ))[0].returnValues;
      var repoIndex1 = returnValues.repoIndex;
      var amount = returnValues.amount;
      expect(repoIndex1).toBe("1");
      expect(amount).toBe("10000000");
    })
  });

  //   it("should not allow you to add erc20 collateral", async () => {
  //
  //     const result = await optionsFactory.addAsset(
  //       "DAI",
  //       "0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359"
  //     )
  //
  //     truffleAssert.eventEmitted(result, 'AssetAdded', (ev) => {
  //       return ev.asset === web3.utils.keccak256("DAI") && ev.addr === '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359'
  //     });
  //
  //     console.log(web3.utils.keccak256("DAI"))
  //     console.log(result.logs[0])
  //
  //
  //   })


    // describe("#changeAsset()", () => {
  //   it("should change an asset correctly", async () => {
  //
  //     const result = await optionsFactory.addAsset(
  //       "DAI",
  //       "0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359"
  //     )
  //
  //     truffleAssert.eventEmitted(result, 'AssetAdded', (ev) => {
  //       return ev.asset === web3.utils.keccak256("DAI") && ev.addr === '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359'
  //     });
  //
  //     console.log(web3.utils.keccak256("DAI"))
  //     console.log(result.logs[0])
  //
  //
  //   })
  //
  //   it("fails if an asset is added twice", async () => {
  //     try {
  //       // await util.setBlockNumberForward(8);
  //       await optionsFactory.addAsset(
  //         "DAI",
  //         "0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359"
  //       )
  //
  //     } catch (err) {
  //       return;
  //       // console.log(err)
  //       // util.assertThrowMessage(err);
  //     }
  //     expect.fail("should throw error")
  //   })
  //
  //
  // });

  // describe("#createOptionsContract()", () => {
  //   it("should change an asset correctly", async () => {
  //     try {
  //       optionsContractAddr = await optionsFactory.createOptionsContract.call(
  //         "ETH",
  //         "ETH",
  //         "95",
  //         "ETH",
  //         "ETH",
  //         "109182389"
  //       );
  //     } catch (err) {
  //       expect.fail("could not create contracts")
  //     }
  //   })
  //
  // });


  describe("#issueOptionTokens()", () => {
    it("should allow you to mint correctly", async () => {

      const repoIndex = 1;
      const numTokens = 10000000/2 ;

      var result = await promisify(cb =>  optionsContract.methods.issueOptionTokens(repoIndex, numTokens).send({from: creatorAddress, gas: '100000'}, cb))
      var returnValues = (await optionsContract.getPastEvents( 'ETHCollateralAdded', { fromBlock: 0, toBlock: 'latest' } ))[0].returnValues;
      console.log(result)
      console.log(returnValues)
    })

    it("should not allow you to mint from wrong repo", async () => {

      // const repoIndex = 1;
      //
      // var result = await promisify(cb =>  optionsContract.methods.issueOptionTokens(repoIndex, numTokens).send({from: creatorAddress, gas: '100000', value: "10000000"}, cb))
      // var returnValues = (await optionsContract.getPastEvents( 'ETHCollateralAdded', { fromBlock: 0, toBlock: 'latest' } ))[0].returnValues;

    })
  });

});